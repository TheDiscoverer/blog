# Java IO演进
## 概念

### 同步 异步
同步指整个处理过顺序执行，当各个过程执行完毕，才返回结果。
异步通常是发送了调用的命令，无需等待调用的结果完成执行完毕就可以收到消息，然后继续执行后续的流程，调用的方法并行的执行。
对于网络IO中，同步指的是用户线程从内核缓冲区中读取数据并写入到用户区，而异步指的是系统内核线程完成数据从内核缓冲区写入到用户区，用户线程不需要进行读写处理了。

### IO阻塞 非阻塞
阻塞和非阻塞是针对进程访问数据的时候IO的才做方式。阻塞方式下，读取或者写入函数一直等待直到完成，非阻塞方式下，读取或写入的方法会立刻返回一个状态值。

## 传统的BIO编程

### 同步阻塞式IO方法
服务器有一个Acceptor线程负责监听端口是否有客户端发起连接，监听到一个连接后创建一个worker线程进行处理。Acceptor继续循环监听。因此，worker线程的数量在兵法情况下和客户端连接数量成1:1关系，严重浪费计算机资源。
其中worker线程是同步的完成数据的读取，由于客户端数据发送比较慢或者网络延迟等原因，缓冲区没有数据可读，而worker线程仍然会处于阻塞状态，一直等待。

### 同步阻塞IO改进方式
为了避免出现一线程一连接的模型方式，后来演进出了通过线程池或者消息队列实现少量线程处理N个客户端的模型，但是底层仍然是采用同步阻塞是IO。利用线程池可以实现线程复用，当线程数量达到最大线程数，客户端发起的任务可以阻塞在任务队列中。从而避免每一个请求都需要创建一个独立线程浪费系统线程资源的问题。

其中的问题在于阻塞IO中，对socket的输入流进行读取操作时候，会一直阻塞下去直到发生了一下三件事情：
- 有数据可读
- 可用的数据已经读取完毕
- IO异常
因此当对方发送请求较慢或者网络传输较慢时，读取输入流的线程可能会长时间阻塞。

同时针对写入时候，也就阻塞直到所有要发送的字节全部写入完毕，或者发生异常。当消息的接收方处理缓慢的时候，将不能及时的从TCP缓冲区读取消息，这将会导致发送方的TCP 的滑动窗口不断减小，降低写入速度。

因此读写操作都是同步阻塞的，阻塞的事件取决于对方IO线程的处理速度和网络的传输速度。
### 