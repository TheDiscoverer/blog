## 数据库
 
### 事务
事务是由一系列对数据库进行操作的集合组成的最小工作单元

#### ACID特性

1. 原子性 整体，不可分割

2. 一致性 事务执行后不会破坏数据库的完整性，也就是从一个正确的状态转换到另一个正确的状态。

3. 持久性 事务执行结束后，对数据库的更改永久写到数据库中，结果不会被撤销。

4. 隔离性 并发执行时互不影响

#### ACID特性如何保证

1. undo保证原子性和一致性。InnoDB中当事务对数据库进行修改的时候，InnoDB后生成对应的undo log，如果事务执行失败或者调用了rollback导致事务需要回滚时，便利用undo log中的信息将数据会滚到修改之前的样子。undo log书与逻辑日志，当发生会滚时，执行undo log中相反的sql 语句。 

2. redo保证持久性。执行某事务时，首先将要修改的数据从磁盘中拷贝到内存，然后对内存数据进行修改。接着将事务的日志写入到redo缓冲区，然后将redo缓存写入到redo文件进行持久化。最后在提交commit，将修改的数据写入到磁盘中。这样当数据写入磁盘失败时候可以利用redo文件进行恢复。

3. 锁以及MVCC保证隔离性


#### 事务并发执行产生的问题

1. 脏读，读取未提交的数据。当事务A修改了数据X，但还没有提交，此时事务B读取了X，接着事务A进行了撤消。

2. 不可重复读，事务B读取了数据X，事务A对数据X进行了修改，事务B接着读取X，导致前后不一致。

3. 幻读，事务A第一次读不存在，然后事务B insert了一条数据，事务A再次读时又出现了。

#### 分布式事务

事务的参与着位于分布式系统的不同节点之上。

1. 两阶段提交

系统角色：协调者，参与着

两阶段：准备阶段，提交阶段

	- 准备阶段，参与着分别执行本地的作业，但不提交，然后告诉协调者自己的决策 提交（本地作业执行成功） 或者取消（本地作业执行故障）

	- 提交阶段，协调者将基于第一阶段的投票结果进行决策，提交或者取消。当且仅当所有的参与者同意提交事务，协调者才通知所有的参与者提交事务，否则协调者通知所有的参与者取消事务。参与者在接收到协调者发来的消息后将执行响应的操作。

缺点：

	- 同步阻塞问题，当参与着占用公共资源时，其他参与着出于阻塞状态。

	- 单点问题，协调发生故障时，参与者会一直阻塞等待协调者返回结果

	- 数据不一致，由于网络原因协调者向参与着发送commit请求之后，部分参与者没有收到消息，因此无法执行事务提交，而其他机器则执行了提交，导致数据不一致。

2. 三阶段提交

### 索引

#### 索引数据结构

1. B+树索引

所有数据记录都是按照键值大小顺序存放在同一层的叶子结点，各个叶子结点通过链表进行连接。非叶子结点交替存储节点指针和kev，key从左到右升序排列。每个指针指向的节点里所有的key都小于等于指针右边的key，大于指针左边的key。

2. B树和B+树的区别

	- B树中非叶子结点也存储数据记录，而B+树中非叶子结点置存储key以及指向其他结点的指针。因此B+树能够保证每个结点能够存储更多的指针，树的层高能够进一步压缩，使得检索时间更短。

	- 叶子结点采用链表形式，方便顺序遍历多个叶子结点。而B树还需要遍历多个非叶子结点，时间比较慢。

	- 对于B树，如果经常访问的数据存在离根节点比较近的节点，访问效率比较高。

3. 哈希索引

InnoDB会自适应创建哈希索引，以O1的时间复杂度实现快速查找。这样会丢失数据的有序性。

4. 全文索引

##### 索引优化

1. SQL语句中索引独立，不能是表达式的一部分，不然索引会失效。

`SELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5;`

2.  使用多列索引

CREATE INDEX PersonIndex ON Person (LastName, FirstName)

使用多列索引后，当我们判断条件有多个时候，首先根据第一个条件过滤掉不符合条件的行，然后根据第二个条件在前一部分过滤的基础上再进行一次过滤。

3. 最左原则

基于多列索引进行数据查询时，让查询条件能够尽可能多的匹配多列索引的左边连续几列。


#### 索引实效的原因

- where子句中使用不等于<>、 !=操作符，会全表扫描

- where子句中使用or作为连接条件时候，如果不是每个列都有独立的索引，那么会全表扫描。可以使用union来代替。

- 对于多列索引，没有基于最左原则

- 列类型是字符串，一定要用单引号阔起来。

- like模糊查询，前模糊和全模糊会导致索引失效。

- 查询条件中没有使用单独的列，使用了运算符或者函数。

- where子句中进行null值判断会全表扫描。

### 数据库原理

#### 键

1. 超键：在关系中能为宜表示元祖的属性集称为关系模式的超键。

2. 候选键：不含有多余书行的超键

3. 主键：选作元组标示的一个候选键称为主键

4. 外键：该数据表的某个属性是另一个数据表的主键，成为该数据表的外键。

5. 主属性：候选键属性的并集

6. 非主属性：不包含在任意候选键中的属性

#### 范式

1. 1NF：关系模式R中每一个属性都是不可分割的单元

2. 除了满足1NF之外，其他非主属性都完全依赖于候选键

3. 除了满足2NF之外，非主属性对任何候选键不存在传递依赖。

#### 连接

1. 内连接

指连接结果仅包含符合连接条件的行du，参与连接的两个表都应该符合连接条件。

2. 自连接

3. 自然连接

两个表相同的列通过等值测试连接起来

4. 外连接

连接结果不仅包含符合连接条件的行同时也包含自身不符合条件的行。包括左外连接、右外连接和全外连接。


左外连接 left outer join 或者 left join

左外连接就是在等值连接的基础上加上主表中的未匹配数据，例:

SELECT *FROM TESTA LEFT OUTER JOIN TESTB ON TESTA.A=TESTB.A

#### union

合并两个查询语句的查询结果。
select * from A
union 
select * from B


##### 建立索引

CREATE TABLE `phpcolor_ad` (  
`id` mediumint(8) NOT NULL AUTO_INCREMENT,  
`name` varchar(30) NOT NULL,  
`type` mediumint(1) NOT NULL,  
`code` text,  
PRIMARY KEY (`id`),  
KEY `type` (`type`)  
);
key 建立普通索引

primary key 建立主键索引，不能为null，唯一

unique key 唯一索引，可以为null

key(a,b)，建立多列索引

### Mysql处理高并发

1. Sql语句优化，尽可能走索引

2. 索引优化

3. 拆分

	- 垂直拆分

		- 分库，将关联度较低的表存储在不同的数据库中，通常按照业务类型独立划分。避免单一数据库读写压力过大。

		- 分表。针对数据库中某一表进行拆分，表字段较多的可以拆分成小表，避免访问出现跨页问题。Mysql底层通过数据页存储的，一条记录占用空间过大会导致跨页，造成额外的性能开销。分表可以提高IO性能。

		- 缺点，记录较多时候仍存在单表数据量过大的问题。

	- 水平拆分

		当一个表难以细粒度垂直且分时候或者数据行数巨大，存在单库读写、存储性能瓶颈时候，需要水平切分。水平拆分分为库内分表喝分库分表。库内分表解决啦单一表数据量过大的问题，但没有将表分到不同的库上，因此对于减轻Mysql的数据库压力来说帮助较小，大家还是竞争同一计算机资源，因此一般通过分库分表来解决。以下为数据库分片规则：

		- 根据数值范围。如时间区间或者id区间进行切分。优点：单表的大小可控，后期如果对集群进行扩容时只需要添加节点即可不需要对其他分片的数据进行迁移，方便连续查询。缺点：如果按照时间区间切分可能导致热点数据集中存储在某个节点中，成为系统瓶颈。

		- 数值取模。优点：数据分片想对均匀，不容易出现热点数据集中存储在某个节点中。缺点：集群需要扩容时候需要迁移旧的数据。

4. 其他
