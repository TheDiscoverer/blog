## Redis

#### 主从同步
- 增量同步。主节点将修改的指令写入到环形数组，移步的将指令同步给从节点，从节点执行指令达到和主节点一样的状态。如果同步比较慢，环形数组中的数组就会被后来的指令覆盖。

- 快照同步。假如出现网络链接状况不好，短时间内从节点无法与主节点保持同步，会导致缓冲区数据被后面的指令流覆盖掉，这是无法实现主从同步。快照同步是首先需要在主库上进行一次 bgsave 将当前内 存的数据全部快照到磁盘文件中，然后再将快照文件的内容全部传送到从节点。从节点全部加载到内存，然后与主节点进行增量同步，因为在快照同步的过程中主节点还会往buffer中写入修改指令。如果快照同步的时间过长或者复制 buffer 太小，都会导致同步期间的增量指令在复制buffer中被覆盖，这样就会导致快照同步完成后无法进行增量复制，然后会再次发起快照同步，如此极有可能会陷入快照同步的死循环。所以务必配置一个合适的复制 buffer 大小参数，避免快照复制的死循环。

#### redis如何保证高可用
通过redis sentinel实现。哨兵集群实时监控主从redis的健康状况。当master节点宕机之后，会从slave中选出一个新的master节点对外提供服务。客户端连接哨兵集群请求新的master节点地址，从而与新master节点连接。

异步复制：主备切换时会发生数据丢失问题，主节点的一些指令因为宕机没有发送给新的master节点。

集群脑裂：同时由于网络分区，master节点无法将数据复制给slave节点。网络恢复后，master可能调整为slave节点，slave变为master，因此导致当前的master丢失一些数据。

解决办法：尽可能减少主从节点之间的数据不一致程度。

min-slaves-to-write 1 
min-slaves-max-lag 10
至少要求一个slave，数据同步的延迟不能超过10m。一旦所有的slave，数据复制和同步的延迟都超过了10秒，这时候master就不再接受任何请求了，一般master宕机这样可以减少异步复制和脑裂导致的数据丢失


#### redis集群
1. codis

2. cluster

#### 过期策略

#### 常见缓存问题
1. 缓存穿透

2. 雪崩

3. 缓存击穿

#### redis单线程
1. 减去锁导致的性能消耗。单线程执行，任务串行执行，不需要考虑竞争锁，没有加锁和释放锁过程。
2. 避免cpu消耗
避免了多线程切换带来的上下文切换的消耗。

#### redis数据删除和内存淘汰机制
1. 数据删除
- 定期删除：每隔一定时间抽取过期时间的key，并进行检查，如果过期则删除
- 惰性删除：每次获取key时会对key 进行判断是否存活，如果过期则删除

2. 内存淘汰机制
- volatile-lru：从已经设置过期时间的数据集中挑出最近最少使用的数据淘汰；
- volatile-ttl：从已经设置过期时间的数据集中挑出最先要过期的数据；
- volatile-random：从已经设置过期时间的数据集中任意选择数据进行淘汰；
- allkey-lru：从所有数据中挑出最近最少使用的数据进行淘汰；
- allkey-random：从数据集中任意选择数据进行淘汰；
- no-enviction：禁止驱逐数据，内存不足时候写入操作就会报错。

#### redis 非阻塞多路复用
- 非阻塞。redis读写操作不回发生阻塞。当调用套接字的read方法时，缓冲区中有多少数据就读多少数据，而不会要求缓冲区有了多少大小的数据read方法才会返回结果。write方法通常不会发生阻塞，除非当写缓冲区已经满了。

- 多路复用。复用一个线程监听多个socket的读写事件，通常是利用系统调用来实现，包括select，poll，epoll等。


#### 缓存-数据库双写一致性
先删除缓存再更新数据库。

1. 为什么删除缓存？频繁的更新缓存耗时，并且更新缓存也不一定保证能够命中。
2. 为什么不是先更新数据库？先更新数据库的话，如果删除缓存失败，则会出现不一致现象。

