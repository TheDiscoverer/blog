## 秒杀系统常见问题

### 如何解决高并发
#### 缓存

将商品信息以及库存数量缓存到Redis中，避免访问数据库，数据库难以支持高并发场景的使用。

1. 缓存预热：利用PostConstruct注解提前讲商品信息加载到缓存中，解决缓存击穿问题。（商品信息作为对象通过序列化缓存，库存数单独缓存）

2. JVM级别缓存：ConcurrentHashMap缓存商品是否卖完信息

#### 限流

常见限流算法：令牌桶算法，漏桶算法，计数器法。对被打回去的流量配合服务降级，返回等待页面等。

#### 集群

1. 应用服务器集群

在Web服务器集群之前部署反向代理服务器（负载均衡服务器），将并发请求路由到不同的应用服务器上，实现集群负载均衡，提高系统高并发情况下的性能。

2. Redis集群

根据商品ID，将商品信息通过哈希算法存储到不同的Redis机器上，保证Redis集群负载均衡。

3. 数据库集群

分库分表

#### 消息队列

削峰、异步

#### 其他

以下主要为自己的实现：

1. Tomcat配置

	- 线程池，最大线程池数量为75最优。

	- IO方式。IO方式包括bio，nio，apr，nio2四种。

		+ bio，阻塞式IO。为每一个连接都创建一个工作线程，工作线程没有读取到数据则处于阻塞状态，浪费服务器资源。

		+ nio，非阻塞IO。一个线程监听多个客户端连接，当发生读事件时，才会创建线程执行任务。

2. JDBC连接池配置

最大连接数目应该大于tomcat的最大连接数，因为tomcat每一个连接可能同时要进行数据库操作。

### 如何防止超卖，如果允许超卖，如何实现

1. 本项目在单应用服务器，单机Redis情况下，将减库存操作放在Redis里实现，通过调用Jedis的hincrBy方法将库存数量-1，如果返回值为小于0，说明该商品无库存，此时返回无库存信息。Redis中所有操作是单线程的，因此减一操作是原子的，不会出现超卖。在多应用服务器情况下，也不会出现超卖。

2. 多应用服务器下在数据库里扣减库存时，利用分布式锁，保证同一时刻只有一个请求能够秒杀某一种商品。（分布式锁：Redis，Zookeeper）（如果使用Redis减库存的话不需要使用分布式锁，因为Redis是单线程的）

3. 大家发起秒杀请求时，服务端把请求按照先到先存的规则放进消息队列，当消息队列达到了一定的大小就说明理论上商品已经抢完了。后续请求则直接返回售光结果。这时再处理消息队列生成订单。一般用于商品种类不多的常见，一种商品创建一个消息队列。（据说小米的做法）

### 秒杀商品实现流程

1. 判断是否超过秒杀时间

2. 通过ConcurrentHashMap判断商品是否卖光

3. Redis中使用Set集合存储订单（用户手机号-商品ID）,通过查询Set集合判断用户是否重复下单。

4. 在Redis中减库存，如果库存数小于0， 则将库存数恢复为0，同时在ConcurrentHashMap中标记该商品已经售光。

5. 在Redis中插入订单，同时将订单同步的持久化到数据库中（修改库存，生成订单）。

### 项目整体开发流程


### 为什么使用Redis作为缓存？

1. Redis单线程，能够保证减库存操作是原子性的，不会出现两个操作同时减一。

2. Redis支持丰富的数据结构，包括list，set，sorted set，hash等。利用set存储订单，避免重复秒杀。

3. Redis支持复制功能，可以构建主从Redis，增加缓存系统的高可用性。

### 如何定义秒杀场景？

1. 

### 目前存在的瓶颈，如何发现系统瓶颈

1. 

### 如何解决JVM级别缓存同步问题

1. Zookeeper