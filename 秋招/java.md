## Java复习

### 1. java基础

#### java三大特性
1. 封装
将事务的属性和行为封装为一个整体，形成类，并隐藏属性和行为的细节，对外仅公开接口。

目的：增强安全性和简化编程，使开发者不需要了解具体的实现细节。

2. 继承
子类继承父类的属性和行为

3. 多态
同一个行为具有不同的表现形式，实现方式包括（1）父类引用变量调用子类的方法，不同的子类具有不同的方法表现形式，继承、重写。（2）接口引用变量调用实现类对象的方法。

目的：让程序依赖于抽象，能够根据不同的需求对使用的类进行调整，而不需要改变调用的部分代码。

#### 重载和重写
1. 重载：在一个类里面，多个方法的名字相同，但是参数不同。
2. 重写：子类对父类的某个方法重写，方法名和参数不变（返回类型可以是派生类），不能跑出更广泛的异常。

#### 为什么重写hashcode方法？
在java的一些容器中，比如hashmap，将一个对象存储到数组的哪一个槽对应的的链表中需要通过对hashcode去hash值然后对数组长度取模得到，并且需要保证equals相同的对象在hashmap中只有一个，因此需要重写hashcode使得equals相同的对象hashcode也相同。

原则：equals相同，hashcode一定要相同。

#### 类的访问权限修饰符
1. public 
全局访问

2. private
类的内部方法可以访问

3. protected
包内和包外子类可以访问

4. 默认
包内访问


#### static
1. 修饰成员变量
类的所有实例化对象共享这一个变量，可以通过类名调用

2. 修饰成员方法
可以通过类名调用

3. 修饰静态代码块
在类初次被加载的时候会调用。

#### final
1. 修饰类
不能被继承

2. 修饰方法
不能被重写

3. 修饰成员变量
只初始化一次，以后不能改变。表示常量

#### 抽象类和接口
1. 抽象类
抽象类使用abstract修饰，方法可以有方法体。抽象类的成员变量可以是各种类型，

2. 接口
接口中的成员变量只能是public static final类型。不能含有静态代码块和静态方法。所有的方法都是都隐式的使用abstract修饰，方法不能包含方法体。

3. 使用场景
- 如果有多个类，他们有公共的方法或者字段，公共方法有些实现相同有些不同，可以使用抽象类，在抽象类中实现该方法。
- 如果需要多重继承，那么必须使用接口，java不允许多继承。

#### 反射
程序运行过程中加载一个类，并能够知道该类的方法和属性，同时能够创建该类的实例访问这些方法和属性。

#### 对象创建流程
1. 父类静态变量初始化，执行父类静态代码块
2. 子类静态变量初始化，执行子类静态代码块
3. 父类成员变量初始化，执行父类代码块
4. 父类构造函数
5. 子类成员变量初始化，执行子类代码块
6. 子类构造函数

### 2. 容器

#### HashMap


#### CurrentHashMap
Segment数组 + HashEntry数组 + 链表，分段锁实现并发
采用两次hash将key映射到对应的元素所在的链表。第一次映射到HashEntry数组，第二次映射到对应的链表头部，这时候修改不需要锁住整个map，只需要锁住对应的HashEntry数组即可。

java8放弃了分段锁的实现，而采用node数组 + 链表 + 红黑树的数据结构，采用CAS + synchronized机制实现并发操作，锁的力度更小。
1. 计算hash值来确定放在数组的哪个位置
2. 如果这个位置为空，则通过cas操作添加。
3. 如果这个位置不为空，则利用synchronized对链表头进行加锁，然后遍历链表判断是否判断该元素的key值是否存在，如果存在则覆盖，否则添加到链表的末尾。

### 3. java虚拟机

#### 虚拟机内存模型
运行时数据区域：方法区，堆，虚拟机栈，本地方法栈，程序计数器。其中方法区和堆是线程共享的。
- 方法区：存储被虚拟机加载的类信息、常量、静态变量、编译器编译后的代码等。
- java堆：存储对象实例包括数组
- 虚拟机栈：java方法执行的内存模型，存储局部变量表，操作栈，方法出口等信息。
- 本地方法栈：native方法执行的内存模型。
- 程序计数器：字节码的行号指示器。

#### 垃圾收集算法
1. 判断对象是否死亡
- 引用计数器法

- 可达性分析法

2. 垃圾清除算法

- 标记整理法

- 标记清除法

- 复制算法

- 分代收集算法

#### 垃圾收集器
1. G1

2. CMS
基于标记清除算法的垃圾收集器。整个过程分四个步骤：
	1. 初始标记。标记GC root能直接关联的对象，速度很快。
	2. 并发标记。并发标记和用户线程共同执行，通过GC root找到它能应用的所有其他对象。
	3. 重新标记。为了修正并发标记阶段由于用户程序而导致产生变动的一部分对象的标记记录。
	4. 并发清除。用户线程和GC线程共同执行。

	优缺点：速度快，并发标记和并发清除持续时间长但是能够和用户程序一起执行。容易产生内存碎片，无法处理浮动垃圾（并发清理阶段用户线程还在运行，这段时间就可能产生新的垃圾，新的垃圾在此次GC无法清除，只能等到下次清理。）。

#### 加载过程
五个步骤：：
1. 加载。将class文件加载到方法区。

2. 验证。验证class文件的是否以魔数开头，并且满足虚拟机版本要求，不会有安全威胁等。

3. 准备。将静态变量赋初始值。

4. 解析。将符号引用替换为直接引用。

5. 初始化。执行类构造器方法的过程，将类中所有类变量的赋值动作和静态语句块合并产生。
